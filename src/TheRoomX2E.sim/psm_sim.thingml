/* This is the PSM the Platform Specific Model */
/*** This version contains a SIMULATED platform */
/* This version has possibility to change the polling intervals for temperature */
import "datatypes.thingml"
import "pim_messages.thingml"
import "psm_datatypes_sim.thingml"
import "javatimer.thingml" // 160310

// PSM specific messages

thing fragment PSM_Msg {
	message initialize(ts:Tellstick);
}

// Here we relate to the given jstick library and kick-down to it from ThingML

thing fragment PSMSensor {
	/* required port provide_val {} // TODO This does not work as override
	provided port require_val {} */
}

thing fragment PSMSensorSet includes PSMSensor {
property sensors: Integer
}

thing fragment PSMSensorSingle includes PSMSensorSet {
}


// We need a way to initialize the Tellstick etc
// This defines the central kick-down concept. The maven_dep stuff refers to an installed Maven project
thing TellstickManager includes PSM_Msg, GeneralMsg
@maven_dep "<dependency>
<groupId>net.juppi</groupId>
<artifactId>jstick-api</artifactId>
<version>1.7</version>
</dependency>"
{ 	/* Ports may be defined here */
	required port to_T1 {
		sends initialize
	}
	
	required port to_T2 {
		sends initialize
	}
	required port to_T3 {
		sends initialize
	}
	
	required port to_onoff1 {
		sends initialize
	}
	
	required port to_onoff2 {
		sends initialize
	}
	required port to_onoff3 {
		sends initialize
	}
	
	required port to_dl {
		sends initialize
	}
	
	required port to_mg1 {
		sends initialize
	}
required port to_mg2 {
		sends initialize
	}



	required port to_gdg {
		sends sensorinfo, deviceinfo
	}
	
	/* properties defined here */
	property ts : Tellstick // this is set in initialize() function
	// property sensor_list:Sensor[25] removed at SIMULATION
	// property device_list:Device[25] removed at SIMULATION
	property i:Integer // runner index in list of sensors or devices
	// property s:Sensor // temporary Sensor removed at SIMULATION
	// property d:Device // temporary Device removed at SIMULATION
	property model:String
	property proto:String
	property sid:Integer // sensor id
	property did:Integer // device id
	property dataTypes:Integer
	property temperature:Double
	property humidity:Long
	property timeStamp:Long
	property name:String
	property devicetype:String
	property devicemethods:Long
	property devicelastcmd:String
	property devicelastval:Long 
	
	property sensor_list:Sensor[25] // removed at SIMULATION
	property device_list:Device[25] // removed at SIMULATION
	property s:Sensor // temporary Sensor removed at SIMULATION
	property d:Device // temporary Device removed at SIMULATION
	
	function observe_sensors() do
		// Now we send to PIM all the Sensor gadgets which are managed by that Tellstick
		``&sensor_list& `=` ``&ts&`.getSensors().toArray(```&sensor_list& `);` // kick-down to tellstick
		i=0
		while (i<25)do
			s=sensor_list[i]
			if (not (s==`null`)) // TODO find a way in ThingML to check existence?
			do
				model=``&s&`.getModel()`
				proto=``&s&`.getProtocol()`
				sid=``&s&`.getId()`
				dataTypes=``&s&`.getDataTypes()`
				temperature=``&s&`.getTemperature()`
				humidity=``&s&`.getHumidity()`
				timeStamp=``&s&`.getTimeStamp()`		
				to_gdg!sensorinfo(model,proto,sid,dataTypes,temperature,humidity,timeStamp)
			end
			i=i+1
		end
	end
	
	function observe_devices() do
		// Now we send to PIM all the Devices actuators which are managed by that Tellstick
		``&device_list& `=` ``&ts&`.getDevices().toArray(```&device_list& `);` // kick-down to tellstick
		i=0
		while (i<25) do
			d=device_list[i]
			if (not (d==`null`)) // TODO not very elegant way to walk through, should use numberofdevices
			do
				did = ``&d&`.getId()`
				name = ``&d&`.getName()`
				model= ``&d&`.getModel()`
				proto = ``&d&`.getProto()`
				devicetype = ``&d&`.getType()`
				devicemethods = ``&d&`.getMethods()`
				devicelastcmd = ``&d&`.getLastCmd()`
				devicelastval = ``&d&`.getLastValue()`
				to_gdg!deviceinfo(did,name,model,proto,devicetype,devicemethods,devicelastcmd,devicelastval)
			end
			i=i+1
		end
	end

	function initialize() do
	// kick-down initialization
		ts = `new net.jstick.api.Tellstick()` // NOTE: Full name of the kick-down class

		to_T1!initialize(ts)
		to_onoff1!initialize(ts)
		to_dl!initialize(ts)
		to_mg1!initialize(ts)
		
		observe_sensors()
		observe_devices()
		
		// Now we send to PIM all the Device i.e. actuator gadgets that exist in the system
		
	end //initialize
	
	statechart TellstickBehavior init Init {
		state Init {
		on entry do 
			initialize()
			
		end }
	}
}

thing ThermometerSet includes PSMSensorSet,TemperatureMsg, GeneralMsg, PSM_Msg, TimerClient {
// TimerClient introduced 160310
	required port provide_val {sends temperature, temprature_sum}
	required port show_values {sends temperature}
	provided port require_val {receives add_thermometer, set_polling_interval}
	provided port initial {receives initialize}
	provided port get_values {receives temperature,temprature_sum} // SIMULATION
	property ts:Tellstick // kick-down 
	
	property thermometers:Integer[25] // Identifiers of the thermometers in the set
	property thermotext:String[25] // corresponding explanatory text 
	
	// SIMULATION
	property thermoval:Double[25] // values to report from the corresponding thermometer
	
	property last_thermo:Integer = 0 // number of thermometers in the set 
	property i:Integer // runner index in list
	property poll_intrvl:Integer = 10000 // polling interval in milliseconds, default is like hardcoded value from X2.sim
	// property s:Sensor // runner Sensor (removed at SIMULATION)
	property id_s:Long // temporary id value (to be used with kick-down)
	property sensortype:Integer // temporary value for sensor type
	property temp_s:Double // temporary temperature value
	property found:Boolean // temporary - true when item found in loop
	property temp_sum:Double = 0
	
	property s:Sensor // runner Sensor
	
	property d:Device // temporary device  
	
	statechart behaviorThermometerSet init Init {
		state Init {
			transition -> Idle
			event temp: initial?initialize
			action do
				ts = temp.ts
				timer!timer_start(poll_intrvl) // starting the polling cycle
			end
		}
		state Idle {
		transition -> Idle
			event timout:timer?timer_timeout // 160310
			action do
				temp_sum = 0
				i=0
				while (i<last_thermo)do
					id_s=thermometers[i]
					s= ``&ts&`.getSensor(`&id_s&`)` 
					if (not (s==`null`)) // TODO find a way in ThingML to check existence?
					do
						sensortype=``&s&`.getDataTypes()`
						if (sensortype==1 or sensortype==3) do
							temp_s=``&s&`.getTemperature()`			
							provide_val!temperature(id_s,thermotext[i],temp_s)
							show_values!temperature(id_s,thermotext[i],temp_s)
							temp_sum = temp_sum + temp_s
						end
					end
					else do
							temp_s=thermoval[i]		
							provide_val!temperature(id_s,thermotext[i],temp_s)
							show_values!temperature(id_s,thermotext[i],temp_s)
							temp_sum = temp_sum + thermoval[i]
					end
					if(i==(last_thermo-1)) do 
						provide_val!temprature_sum(temp_sum)
					end
					i=i+1
				end 
				timer!timer_start(poll_intrvl) // restarting the polling cycle
			end
			
			transition -> Idle
			event pollintrvl:require_val?set_polling_interval
			action do
				poll_intrvl = pollintrvl.intrvl
			end
			
			transition -> Idle
			event addt:require_val?add_thermometer
			action do	
				id_s=addt.id
				s= ``&ts&`.getSensor(`&id_s&`)`
				if (not (s==`null`)) do
					sensortype=``&s&`.getDataTypes()`
					if (sensortype==1 or sensortype==3) do
						thermometers[last_thermo]=id_s
						thermotext[last_thermo]=addt.txt
						last_thermo = last_thermo+1
						timer!timer_start(poll_intrvl)
					end
				end
				else do
					thermometers[last_thermo]=id_s
					thermotext[last_thermo]=addt.txt
					thermoval[last_thermo]= 10 // just a default temperature
					last_thermo = last_thermo+1
					timer!timer_start(poll_intrvl)
				end
				println("added default thermo")
			end
			
			
			// SIMULATION receiving temperature from simulation interface
			transition -> Idle
			event put_temp:get_values?temperature
			action do
				id_s=put_temp.id
				temp_sum = 0
				i=0
				s= ``&ts&`.getSensor(`&id_s& `)`				
				while (i<last_thermo) do
					if (not (s==`null`)) do
						sensortype=``&s&`.getDataTypes()`
						if((sensortype==1 or sensortype==3)) do
							temp_s=``&s&`.getTemperature()`		
							temp_sum = temp_sum + temp_s
						end
					end
					else if (id_s==thermometers[i] and (s==`null`)) do
						thermoval[i]=put_temp.t	
						temp_sum = temp_sum + thermoval[i]
					end
					i=i+1
				end
				//provide_val!av_temprature((temp_sum/(i)))
				
			end
			
			
		}
	}
} // ThermometerSet



thing OnOffSet includes PSM_Msg, GeneralMsg, OnOffMsg{
	provided port require_val {receives SwitchOn, SwitchOff, add_device}
	provided port initial {receives initialize}
	required port show_val {sends SwitchOn, SwitchOff}
	
	property ts:Tellstick // kick-down 
	property onoffswitches:Integer[25] // Identifiers of the onoffswitches in the set
	property last_onoff:Integer = 0 // number of onoff switches in the set 
	
	// SIMULATION
	property poweron:Boolean[25] // SIMULATION false=OFF true=ON for corresponding switches
	
	property i:Integer // runner index in list
	property did:Integer // temporary device id
	property d:Device // temporary device removed at SIMULATION
	property mth:Long // temporary methods
	property found:Boolean // temporary boolean used in while loop
	property status:Long // of either ON or OFF not very reliable since no real result is returned
	
	statechart behaviorOnOffSet init Init {
		state Init {
			transition -> Idle
			event initial: initial?initialize
			action do
				ts = initial.ts
			end
		}
		state Idle {
			transition -> Idle
			event add_dev: require_val?add_device
			action do
				did=add_dev.did
				
				d= ``&ts&`.getDevice(`&did&`)`
				if (not (d==`null`)) do
					mth =``&d&`.getMethods()`
					if (mth==3) do
						onoffswitches[last_onoff]=did
						last_onoff = last_onoff+1
					end
				end
				else do 
					onoffswitches[last_onoff]=did
					last_onoff = last_onoff+1
				end
				
			end
			transition -> Idle
			event swon: require_val?SwitchOn
			action do
				did=swon.did
				i=0
				found = false
				while (i<last_onoff and (not found)) do
					if (did==onoffswitches[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				
				if (found) do
					d= ``&ts&`.getDevice(`&did&`)`
					if ((not (d==`null`))) do
						mth =``&d&`.getMethods()`
						if (mth==3) do
							`int dident=```&did&`;`
							`int x= `&ts&`.sendCmd(dident,"ON");`
							status = `x`
							// ``&status& `=` ``&ts&`.sendCmd(``` &did& `, "ON" );`  TODO does not compile,yet
							// status =``&ts&`.sendCmd(`& did &`, "ON" )`
						end
						// TODO We need an error outcome if it is the wrong type as well
					end
					else do
						poweron[i-1]=true // ON by SIMULATION
						show_val!SwitchOn(did)
						// TODO remove when tested print("SIMULATION: Power ON on device #") print(did) print("\n")
					end
				end
				
			end
			transition -> Idle
			event swoff: require_val?SwitchOff
			action do
				did=swoff.did
				i=0
				found = false
				while (i<last_onoff and (not found)) do
					if (did==onoffswitches[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				if (found) do
					d= ``&ts&`.getDevice(`&did&`)`
					if (not (d==`null`)) do
						mth =``&d&`.getMethods()`
						if (mth==3) do
							`int dident=```&did&`;`
							`int x= `&ts&`.sendCmd(dident,"OFF");`
							status = `x`
							// ``&status& `=` ``&ts&`.sendCmd(``` &did& `, "OFF" );`  TODO does not compile,yet
						end
						// TODO We need an error outcome if it is the wrong type as well
					end
					else do 
						poweron[i-1]=false // OFF by SIMULATION
						show_val!SwitchOff(did)
						// TODO remove when tested print("SIMULATION: Power OFF on device #") print(did) print("\n")
					end
				end
			end
			
		}
	}
}


thing MagneticSensorSet includes PSM_Msg, GeneralMsg, OpenedShutMsg{
	required port provide_val {sends WindowOpened, WindowShut}
	required port show_val {sends WindowOpened, WindowShut,WindowIsAlreadyOpen,WindowIsAlreadyShut}
	provided port require_val {receives add_magneticSensor}
	provided port get_values {receives WindowOpened, WindowShut}
	
	provided port initial {receives initialize}
	
	property ts:Tellstick // kick-down 
	
	property magneticSensors:Integer[25] // Identifiers of the mg sensors in the set
	property magneticSensortext:String[25] // corresponding explanatory text 
	
	property found:Boolean 
	property i:Integer // runner index in list
	property magneticSensorval:Integer[25] 
	property id_mgs:Long
	property last_mgSensor:Integer = 0 
	property windowShut:Integer =1
	property windowOpened:Integer =2
	
	statechart behaviorMagneticSensorSet init Init{
		state Init {
			transition -> Idle
			event initial: initial?initialize
			action do
				ts = initial.ts
			end
		}
		
		state Idle {
			transition -> Idle
			event addmgs:require_val?add_magneticSensor
			action do				
				id_mgs=addmgs.mgid
				magneticSensors[last_mgSensor]=id_mgs
				magneticSensortext[last_mgSensor]=addmgs.txt
				// just a default status
				magneticSensorval[last_mgSensor]=windowShut
				last_mgSensor = last_mgSensor+1
				
				provide_val!WindowShut(id_mgs)
				show_val!WindowShut(id_mgs)
			end
			
			transition -> Idle
			event open_window:get_values?WindowOpened
			action do
				id_mgs=open_window.mgid
				
				i=0
				found = false
				while (i<last_mgSensor and (not found)) do
					if (id_mgs==magneticSensors[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				if (found and ( magneticSensorval[i-1]!=windowOpened) as Boolean) do
					magneticSensorval[i-1]=windowOpened
					provide_val!WindowOpened(id_mgs)
					show_val!WindowOpened(id_mgs)
				end
				else if (found and ( magneticSensorval[i-1]==windowOpened) as Boolean) do show_val!WindowIsAlreadyOpen(id_mgs) end
			end
			
			transition -> Idle
			event close_window:get_values?WindowShut
			action do
				id_mgs=close_window.mgid
				
				i=0
				found = false
				while (i<last_mgSensor and (not found)) do
					if (id_mgs==magneticSensors[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				if (found and ( magneticSensorval[i-1]!=windowShut) as Boolean) do
					magneticSensorval[i-1]=windowShut
					provide_val!WindowShut(id_mgs)
					show_val!WindowShut(id_mgs)
				end
				else if (found and ( magneticSensorval[i-1]==windowShut) as Boolean) do show_val!WindowIsAlreadyShut(id_mgs) end
			end
			
		}
	}
}

thing DoorLock includes PSM_Msg, GeneralMsg, OpenedShutLockedMsg,TimerClient{
	required port provide_val {sends DoorOpened, DoorShut,DoorLocked}
	required port show_val {sends DoorOpened, DoorShut,DoorLocked,AlarmOn,AlarmOff, BeepOn,BeepOff,DoorIsAlreadyLocked,DoorIsAlreadyOpen,DoorIsAlreadyShut}
	provided port require_val {receives add_doorLockSensor}
	provided port get_values {receives DoorOpened, DoorShut,DoorLocked}
	provided port initial {receives initialize}
	provided port require_alarm_beel_val {receives TurnAlarmOn,TurnAlarmOff,TurnBeepOn,TurnBeepOff}
	property ts:Tellstick // kick-down 
	
	property doorLocks:Integer[1] // Identifiers of the door lock sensors in the set
	property doorLocktext:String[1] // corresponding explanatory text 
	
	property doorLockval:Integer[25] 
	property found:Boolean 
	property i:Integer // runner index in list
	
	property id_dl:Long
	property last_dlSensor:Integer = 0 
	property doorOpened:Integer = 1
	property doorShut:Integer = 2
	property doorLocked:Integer = 3
	property windowCouldBeOpen:Boolean=false
	
	statechart behaviorDoorLock init Init{
		state Init {
			transition -> Idle
			event initial: initial?initialize
			action do
				ts = initial.ts
			end
		}
		
		state Idle {
			
			transition -> Idle
			event addLock:require_val?add_doorLockSensor
			action do				
				id_dl=addLock.dlid
				doorLocks[last_dlSensor]=id_dl
				doorLocktext[last_dlSensor]=addLock.txt
				doorLockval[last_dlSensor]=doorLocked // just a default status
				last_dlSensor = last_dlSensor+1
				
				provide_val!DoorLocked(id_dl)
				show_val!DoorLocked(id_dl)
			end
			
			transition -> Idle
			event open_door:get_values?DoorOpened
			action do
				id_dl=open_door.dlid
				
				i=0
				found = false
				while (i<last_dlSensor and (not found)) do
					if (id_dl==doorLocks[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				if (found and (doorLockval[i-1]!=doorOpened) as Boolean) do
					doorLockval[i-1]=doorOpened
					provide_val!DoorOpened(id_dl)
					show_val!DoorOpened(id_dl)
					//if(windowCouldBeOpen == true)do show_val!BeepOff(id_dl) end
				end
				else if (found and ( doorLockval[i-1]==doorOpened) as Boolean) do show_val!DoorIsAlreadyOpen(id_dl) end
				
			end
			//door alarm transition 
			transition -> Idle
			event locked_door:require_alarm_beel_val?TurnAlarmOn
			action do
				id_dl=locked_door.dlid
				 show_val!AlarmOn(id_dl)
				windowCouldBeOpen = true
			end
			transition -> Idle
			event locked_door:require_alarm_beel_val?TurnAlarmOff
			action do
				id_dl=locked_door.dlid
				 show_val!AlarmOff(id_dl) 
				windowCouldBeOpen = false
			end
			
			transition -> Idle
			event locked_door:require_alarm_beel_val?TurnBeepOn
			action do
				id_dl=locked_door.dlid
				show_val!BeepOn(id_dl)
				if(windowCouldBeOpen == false)do show_val!BeepOn(id_dl) end
				windowCouldBeOpen = true
			end
			transition -> Idle
			event locked_door:require_alarm_beel_val?TurnBeepOff
			action do
				id_dl=locked_door.dlid
				show_val!BeepOff(id_dl)
				if(windowCouldBeOpen == true)do show_val!BeepOff(id_dl) end
				windowCouldBeOpen = false
			end
			
			//end alarm
			
			transition -> Idle
			event shut_door:get_values?DoorShut
			action do
				id_dl=shut_door.dlid
				
				i=0
				found = false
				while (i<last_dlSensor and (not found)) do
					if (id_dl==doorLocks[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				if (found and (doorLockval[i-1]!=doorShut) as Boolean) do
					doorLockval[i-1]=doorShut
					provide_val!DoorShut(id_dl)
					show_val!DoorShut(id_dl)
				end
				else if (found and ( doorLockval[i-1]==doorShut) as Boolean) do show_val!DoorIsAlreadyShut(id_dl) end
			end
			
			transition -> Idle
			event lock_door:get_values?DoorLocked
			action do
				id_dl=lock_door.dlid
				
				i=0
				found = false
				while (i<last_dlSensor and (not found)) do
					if (id_dl==doorLocks[i]) do
						found=true // trick to terminate while loop
					end
					i=i+1
				end
				if (found and ( doorLockval[i-1]!=doorLocked) as Boolean) do
					doorLockval[i-1]=doorLocked
					provide_val!DoorLocked(id_dl)
					show_val!DoorLocked(id_dl)
				end
				else if (found and ( doorLockval[i-1]==doorLocked) as Boolean) do show_val!DoorIsAlreadyLocked(id_dl) end
			end
		}
	}
	
}

//SIMULATION
thing TempSim includes TemperatureMsg 
@mock "true"
{ 	required port give_values {
		sends temperature
	}
	provided port show_values {
		receives temperature
	}
}

thing GadgetSim includes GeneralMsg
@mock "true"
{	provided port show_gadgets {
		receives sensorinfo, deviceinfo
	}
}

thing OnOffSim includes OnOffMsg 
@mock "true"
{	provided port show_onoff {
		receives SwitchOn, SwitchOff
	}
}

thing WindowSim includes OpenedShutMsg 
@mock "true"
{	
	required port give_values {
		sends WindowOpened, WindowShut
	}
	provided port show_openshut {
		receives WindowOpened, WindowShut
	}
}

thing DoorLockSim includes OpenedShutLockedMsg 
@mock "true"
{	
	required port give_values {
		sends DoorOpened, DoorShut, DoorLocked
	}
	provided port show_openshutlocked {
		receives DoorOpened, DoorShut, DoorLocked
	}
	provided port show_alarm_beep {
		receives BeepOn,BeepOff,AlarmOn,AlarmOff
	}
	
}
